//
// Copyright (C) 2020 OpenSim Ltd.
//
// SPDX-License-Identifier: LGPL-3.0-or-later
//


#include "inet/queueing/source/ActivePacketSource.h"

using namespace std;
namespace inet {
namespace queueing {

Define_Module(ActivePacketSource);

void ActivePacketSource::initialize(int stage)
{
    ClockUserModuleMixin::initialize(stage);
    if (stage == INITSTAGE_LOCAL) {
        initialProductionOffset = par("initialProductionOffset");
        productionIntervalParameter = &par("productionInterval");
        productionTimer = new ClockEvent("ProductionTimer");
        scheduleForAbsoluteTime = par("scheduleForAbsoluteTime");
        streamingEnabled = par("streamingEnabled");

        if(streamingEnabled==false){\
            //SRP like stream registration will be triggered
            std::cout << "-----> ActivePacketSource initialized at " << (this->getParentModule())->getParentModule()->getFullName() << endl;
            cMessage *event = new cMessage("TA msg");
            event->setKind(MSGKIND_SEND_TA);
            std::cout << "-----> START time is " << initialProductionOffset << endl;
            scheduleAt(initialProductionOffset.asSimTime(), event);
        }

    }
    else if (stage == INITSTAGE_QUEUEING) {
        checkPacketOperationSupport(outputGate);
        if (!productionTimer->isScheduled())
            scheduleProductionTimerAndProducePacket();
    }
}

void ActivePacketSource::handleMessage(cMessage *message)
{

    if (message->getKind()== MSGKIND_SEND_TA){
        sendStreamRequestMessage();
        std::cout <<  this->getFullPath() << simTime() << "TA generation triggered" << endl;
        delete message;
        return;
    }

    if (message == productionTimer) {
        if (consumer == nullptr || consumer->canPushSomePacket(outputGate->getPathEndGate())) {
            scheduleProductionTimer(productionIntervalParameter->doubleValue());
            producePacket();
        }
    }
    else
        throw cRuntimeError("Unknown message");
}

void ActivePacketSource::handleParameterChange(const char *name)
{
    if (!strcmp(name, "initialProductionOffset"))
        initialProductionOffset = par("initialProductionOffset");

    if (!strcmp(name, "streamingEnabled"))
        streamingEnabled = par("streamingEnabled");

}

void ActivePacketSource::scheduleProductionTimer(clocktime_t delay)
{
    if (scheduleForAbsoluteTime)
        scheduleClockEventAt(getClockTime() + delay, productionTimer);
    else
        scheduleClockEventAfter(delay, productionTimer);
}

void ActivePacketSource::scheduleProductionTimerAndProducePacket()
{
    if (!initialProductionOffsetScheduled && initialProductionOffset >= CLOCKTIME_ZERO  && streamingEnabled==true) {
        scheduleProductionTimer(initialProductionOffset);
        initialProductionOffsetScheduled = true;
    }
    else if (streamingEnabled==true && (consumer == nullptr || consumer->canPushSomePacket(outputGate->getPathEndGate()))) {
        scheduleProductionTimer(productionIntervalParameter->doubleValue());
        producePacket();
    }
}

void ActivePacketSource::producePacket()
{
    auto packet = createPacket();
    EV_INFO << "Producing packet" << EV_FIELD(packet) << EV_ENDL;
    emit(packetPushedSignal, packet);
    pushOrSendPacket(packet, outputGate, consumer);
    updateDisplayString();
}

void ActivePacketSource::handleCanPushPacketChanged(cGate *gate)
{
    Enter_Method("handleCanPushPacketChanged");
    if (!productionTimer->isScheduled())
        scheduleProductionTimerAndProducePacket();
}

void ActivePacketSource::handlePushPacketProcessed(Packet *packet, cGate *gate, bool successful)
{
    Enter_Method("handlePushPacketProcessed");
}


void ActivePacketSource::sendStreamRequestMessage()
{
    auto packet = createPacket();
    packet->setKind(MSGKIND_SEND_TA);

    packet->addPar("sid"); //todo of cuc
    packet->par("sid").setStringValue("-1");

    packet->addPar("talker");
    packet->par("talker").setStringValue( this->getParentModule()->getParentModule()->getFullName());

    packet->addPar("listener");
    cModule* ioModule = this->getParentModule()->getSubmodule("io");
    packet->par("listener").setStringValue(ioModule->par("destAddress"));

    packet->addPar("service_type");
    packet->par("service_type").setStringValue("-1"); //todo of cuc

    double max_pac_size = 1.0 *  par("packetLength").intValue()*8; //bit
    double period_s = par("productionInterval").doubleValue(); //sec
    double max_data = max_pac_size/period_s;
    packet->addPar("max_data");
    packet->par("max_data").setStringValue(std::to_string(max_data));

    packet->addPar("max_latency");
    packet->par("max_latency").setStringValue("100");



    cModule * base = ((this->getParentModule())->getParentModule())->getParentModule();
    cModule * targetModule = (base->getSubmodule("tsnController"))->getSubmodule("cuc");
    cGate *targetGate = targetModule->gate("userInterfaces$i");
    sendDirect(packet, targetGate);




}

} // namespace queueing
} // namespace inet

